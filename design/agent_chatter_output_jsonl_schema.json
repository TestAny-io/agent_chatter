{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Agent Chatter Internal Event Stream Schema",
  "description": "Unified JSONL event format for multi-agent conversation orchestration",
  "version": "1.0.0-draft",
  "lastUpdated": "2025-11-23",

  "designPrinciples": [
    "Unified: One format for all agent types (Claude, Codex, Gemini)",
    "Complete: Preserve all data from source (ETL principle: don't decide for consumers what to keep/discard)",
    "Extensible: Easy to add new agent types",
    "Flat: Avoid deep nesting for easier parsing",
    "Timestamped: All events have timestamps for replay",
    "Self-contained: Each event is independently understandable with team context"
  ],

  "useCases": [
    "UI: Real-time display of agent activities (thinking, tool calls, results)",
    "Context: Build conversation context from event stream",
    "Logger: Record and replay agent sessions",
    "Debug: Troubleshoot agent behavior"
  ],

  "eventTypes": [
    {
      "type": "session.started",
      "description": "Agent session begins (maps to thread.started/system.init/init)",
      "schema": {
        "type": "object",
        "required": ["type", "eventId", "timestamp", "agentId", "agentType", "teamMetadata"],
        "properties": {
          "type": { "const": "session.started" },
          "eventId": {
            "type": "string",
            "description": "UUID for this event",
            "example": "evt_a1b2c3d4"
          },
          "timestamp": {
            "type": "number",
            "description": "Unix timestamp in milliseconds",
            "example": 1732345678901
          },
          "agentId": {
            "type": "string",
            "description": "Member/role ID from team config",
            "example": "max"
          },
          "agentType": {
            "enum": ["claude-code", "openai-codex", "google-gemini"],
            "description": "Type of agent"
          },
          "teamMetadata": {
            "type": "object",
            "description": "Team and member context from team config",
            "required": ["teamName", "memberName", "memberRole"],
            "properties": {
              "teamName": { "type": "string", "example": "phoenix-prd-team" },
              "teamDisplayName": { "type": "string", "example": "Project Phoenix - PRD & Market Strategy Team" },
              "memberName": { "type": "string", "example": "max" },
              "memberDisplayName": { "type": "string", "example": "Max" },
              "memberRole": { "type": "string", "example": "tech-lead" },
              "memberDisplayRole": { "type": "string", "example": "Tech Lead (Innovative)" },
              "themeColor": { "type": "string", "example": "cyan" }
            }
          },
          "sessionId": {
            "type": "string",
            "description": "Original session ID from agent CLI",
            "example": "019aaf35-e498-7842-9ea0-21b84a4764cd"
          },
          "metadata": {
            "type": "object",
            "description": "Optional metadata (model, version, etc.)",
            "properties": {
              "model": { "type": "string" },
              "cliVersion": { "type": "string" },
              "permissionMode": { "type": "string" }
            }
          }
        }
      },
      "mappingRules": {
        "codex": "thread.started → session.started",
        "claude": "system.init → session.started",
        "gemini": "init → session.started"
      }
    },
    {
      "type": "text",
      "description": "Text output from agent (thinking, reasoning, final message)",
      "schema": {
        "type": "object",
        "required": ["type", "eventId", "timestamp", "agentId", "agentType", "content", "teamMetadata"],
        "properties": {
          "type": { "const": "text" },
          "eventId": { "type": "string" },
          "timestamp": { "type": "number" },
          "agentId": { "type": "string" },
          "agentType": { "enum": ["claude-code", "openai-codex", "google-gemini"] },
          "teamMetadata": {
            "type": "object",
            "description": "Team and member context from team config",
            "required": ["teamName", "memberName", "memberRole"],
            "properties": {
              "teamName": { "type": "string" },
              "teamDisplayName": { "type": "string" },
              "memberName": { "type": "string" },
              "memberDisplayName": { "type": "string" },
              "memberRole": { "type": "string" },
              "memberDisplayRole": { "type": "string" },
              "themeColor": { "type": "string" }
            }
          },
          "content": {
            "type": "string",
            "description": "Text content (may be partial if streaming)"
          },
          "role": {
            "enum": ["assistant", "system"],
            "description": "Who is speaking",
            "default": "assistant"
          },
          "delta": {
            "type": "boolean",
            "description": "True if this is a streaming chunk (not complete message)",
            "default": false
          },
          "category": {
            "enum": ["thinking", "reasoning", "message", "response"],
            "description": "Type of text content (UI rendering will differ between thinking/reasoning vs message/response)"
          }
        }
      },
      "mappingRules": {
        "codex": [
          "item.completed (type=reasoning, text=X) → text (content=X, category=reasoning)",
          "item.completed (type=agent_message, text=X) → text (content=X, category=message)"
        ],
        "claude": [
          "assistant.content[] (type=text, text=X) → text (content=X, category=response)"
        ],
        "gemini": [
          "message (role=assistant, content=X, delta=true) → text (content=X, delta=true)",
          "message (role=assistant, content=X, delta=false) → text (content=X, delta=false)"
        ]
      },
      "notes": [
        "For Gemini, preserve delta flag for streaming display",
        "For Codex reasoning, use category=reasoning for special UI treatment",
        "For Claude, each assistant message may produce multiple text events"
      ]
    },
    {
      "type": "tool.started",
      "description": "Tool/command execution begins",
      "schema": {
        "type": "object",
        "required": ["type", "eventId", "timestamp", "agentId", "agentType", "toolName", "toolId", "teamMetadata"],
        "properties": {
          "type": { "const": "tool.started" },
          "eventId": { "type": "string" },
          "timestamp": { "type": "number" },
          "agentId": { "type": "string" },
          "agentType": { "enum": ["claude-code", "openai-codex", "google-gemini"] },
          "teamMetadata": {
            "type": "object",
            "description": "Team and member context from team config",
            "required": ["teamName", "memberName", "memberRole"],
            "properties": {
              "teamName": { "type": "string" },
              "teamDisplayName": { "type": "string" },
              "memberName": { "type": "string" },
              "memberDisplayName": { "type": "string" },
              "memberRole": { "type": "string" },
              "memberDisplayRole": { "type": "string" },
              "themeColor": { "type": "string" }
            }
          },
          "toolName": {
            "type": "string",
            "description": "Normalized tool name",
            "enum": ["Bash", "Read", "Write", "Edit", "Glob", "Grep", "Other"],
            "example": "Bash"
          },
          "toolId": {
            "type": "string",
            "description": "Unique ID for this tool invocation (to match with tool.completed)",
            "example": "item_1"
          },
          "input": {
            "type": "object",
            "description": "Tool input parameters (preserved completely, not truncated)",
            "examples": [
              { "command": "/bin/zsh -lc pwd" },
              { "file_path": "/path/to/file.txt" },
              { "file_path": "/path/to/file.txt", "content": "Hello" }
            ]
          },
          "rawToolName": {
            "type": "string",
            "description": "Original tool name from agent (for debugging)",
            "example": "command_execution"
          }
        }
      },
      "mappingRules": {
        "codex": [
          "item.started (type=command_execution, id=X, command=Y) → tool.started (toolName=Bash, toolId=X, input={command:Y})"
        ],
        "claude": [
          "assistant.content[] (type=tool_use, id=X, name=Write, input=Y) → tool.started (toolName=Write, toolId=X, input=Y)"
        ],
        "gemini": [
          "tool_use (tool_name=read_file, tool_id=X, parameters=Y) → tool.started (toolName=Read, toolId=X, input=Y)",
          "tool_use (tool_name=list_directory, tool_id=X, parameters=Y) → tool.started (toolName=Bash, toolId=X, input={command:'ls'})"
        ]
      },
      "toolNameNormalization": {
        "description": "Map different agent tool names to unified names",
        "rules": {
          "Bash/command_execution/list_directory": "Bash",
          "Read/read_file": "Read",
          "Write/write_file": "Write",
          "Edit/edit_file": "Edit",
          "Glob/find_files": "Glob",
          "Grep/search_files": "Grep"
        }
      }
    },
    {
      "type": "tool.completed",
      "description": "Tool/command execution finishes",
      "schema": {
        "type": "object",
        "required": ["type", "eventId", "timestamp", "agentId", "agentType", "toolId", "teamMetadata"],
        "properties": {
          "type": { "const": "tool.completed" },
          "eventId": { "type": "string" },
          "timestamp": { "type": "number" },
          "agentId": { "type": "string" },
          "agentType": { "enum": ["claude-code", "openai-codex", "google-gemini"] },
          "teamMetadata": {
            "type": "object",
            "description": "Team and member context from team config",
            "required": ["teamName", "memberName", "memberRole"],
            "properties": {
              "teamName": { "type": "string" },
              "teamDisplayName": { "type": "string" },
              "memberName": { "type": "string" },
              "memberDisplayName": { "type": "string" },
              "memberRole": { "type": "string" },
              "memberDisplayRole": { "type": "string" },
              "themeColor": { "type": "string" }
            }
          },
          "toolId": {
            "type": "string",
            "description": "Must match toolId from tool.started"
          },
          "output": {
            "type": "string",
            "description": "Tool output (complete, not truncated - consumers decide how to display)",
            "example": "/Users/kailaichen/Downloads/source code/agent_chatter"
          },
          "exitCode": {
            "type": ["integer", "null"],
            "description": "Exit code for commands (0=success, null=N/A)",
            "example": 0
          },
          "error": {
            "type": ["string", "null"],
            "description": "Error message if tool failed"
          },
          "status": {
            "enum": ["success", "error"],
            "description": "Execution status"
          },
          "metadata": {
            "type": "object",
            "description": "Additional metadata (file paths, changes, etc.)",
            "properties": {
              "filePath": { "type": "string" },
              "changes": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "path": { "type": "string" },
                    "kind": { "enum": ["add", "modify", "delete"] }
                  }
                }
              }
            }
          }
        }
      },
      "mappingRules": {
        "codex": [
          "item.completed (type=command_execution, id=X, exit_code=0, aggregated_output=Y) → tool.completed (toolId=X, status=success, output=Y, exitCode=0)",
          "item.completed (type=file_change, id=X, changes=Y) → tool.completed (toolId=X, status=success, metadata={changes:Y})"
        ],
        "claude": [
          "user.content[] (type=tool_result, tool_use_id=X, content=Y) → tool.completed (toolId=X, status=success, output=Y)"
        ],
        "gemini": [
          "tool_result (tool_id=X, status=success, output=Y) → tool.completed (toolId=X, status=success, output=Y)"
        ]
      },
      "notes": [
        "output is preserved completely (ETL principle: consumers decide display truncation)",
        "For file operations, use metadata.filePath to show which file was affected",
        "exitCode only meaningful for Bash/command_execution"
      ]
    },
    {
      "type": "turn.completed",
      "description": "Current turn (user request + agent response) completes",
      "schema": {
        "type": "object",
        "required": ["type", "eventId", "timestamp", "agentId", "agentType", "teamMetadata"],
        "properties": {
          "type": { "const": "turn.completed" },
          "eventId": { "type": "string" },
          "timestamp": { "type": "number" },
          "agentId": { "type": "string" },
          "agentType": { "enum": ["claude-code", "openai-codex", "google-gemini"] },
          "teamMetadata": {
            "type": "object",
            "description": "Team and member context from team config",
            "required": ["teamName", "memberName", "memberRole"],
            "properties": {
              "teamName": { "type": "string" },
              "teamDisplayName": { "type": "string" },
              "memberName": { "type": "string" },
              "memberDisplayName": { "type": "string" },
              "memberRole": { "type": "string" },
              "memberDisplayRole": { "type": "string" },
              "themeColor": { "type": "string" }
            }
          },
          "finishReason": {
            "enum": ["done", "error", "cancelled", "timeout"],
            "description": "Why the turn ended"
          },
          "usage": {
            "type": "object",
            "description": "Token usage statistics",
            "properties": {
              "inputTokens": { "type": "integer" },
              "outputTokens": { "type": "integer" },
              "cachedInputTokens": { "type": "integer" },
              "totalTokens": { "type": "integer" }
            }
          },
          "cost": {
            "type": "object",
            "description": "Cost information (if available)",
            "properties": {
              "totalUsd": { "type": "number" },
              "currency": { "type": "string", "default": "USD" }
            }
          },
          "duration": {
            "type": "object",
            "description": "Timing information",
            "properties": {
              "totalMs": { "type": "integer" },
              "apiMs": { "type": "integer" }
            }
          }
        }
      },
      "mappingRules": {
        "codex": [
          "turn.completed (usage=X) → turn.completed (finishReason=done, usage=X)"
        ],
        "claude": [
          "result (subtype=success, total_cost_usd=X, usage=Y, duration_ms=Z) → turn.completed (finishReason=done, cost={totalUsd:X}, usage=Y, duration={totalMs:Z})"
        ],
        "gemini": [
          "result (status=success, stats=X) → turn.completed (finishReason=done, usage={totalTokens:X.total_tokens}, duration={totalMs:X.duration_ms})"
        ]
      }
    },
    {
      "type": "error",
      "description": "Error occurred during agent execution",
      "schema": {
        "type": "object",
        "required": ["type", "eventId", "timestamp", "agentId", "agentType", "error", "teamMetadata"],
        "properties": {
          "type": { "const": "error" },
          "eventId": { "type": "string" },
          "timestamp": { "type": "number" },
          "agentId": { "type": "string" },
          "agentType": { "enum": ["claude-code", "openai-codex", "google-gemini"] },
          "teamMetadata": {
            "type": "object",
            "description": "Team and member context from team config",
            "required": ["teamName", "memberName", "memberRole"],
            "properties": {
              "teamName": { "type": "string" },
              "teamDisplayName": { "type": "string" },
              "memberName": { "type": "string" },
              "memberDisplayName": { "type": "string" },
              "memberRole": { "type": "string" },
              "memberDisplayRole": { "type": "string" },
              "themeColor": { "type": "string" }
            }
          },
          "error": {
            "type": "string",
            "description": "Error message"
          },
          "stack": {
            "type": "string",
            "description": "Stack trace (if available)"
          },
          "code": {
            "type": "string",
            "description": "Error code (if available)",
            "example": "JSONL_PARSE_ERROR"
          }
        }
      },
      "mappingRules": {
        "codex": [
          "Parse error → error (error='Failed to parse JSONL', code='JSONL_PARSE_ERROR')"
        ],
        "claude": [
          "result (subtype=error, is_error=true) → error (error=message)",
          "Parse error → error (error='Failed to parse JSONL', code='JSONL_PARSE_ERROR')"
        ],
        "gemini": [
          "result (status=error) → error (error=message)",
          "Parse error → error (error='Failed to parse JSONL', code='JSONL_PARSE_ERROR')"
        ]
      }
    }
  ],

  "conversionRules": {
    "timestampGeneration": {
      "description": "Timestamp handling varies by agent type",
      "rule": "Gemini: Parse ISO 8601 timestamp from source event. Claude/Codex: Use Date.now() at parse time (source events lack timestamps)"
    },
    "eventIdGeneration": {
      "description": "Generate UUID for each output event",
      "rule": "Use crypto.randomUUID() or similar"
    },
    "teamMetadataInjection": {
      "description": "Every event must include team context from team config",
      "rule": "Extract team.name, team.displayName, member.name, member.displayName, member.role, member.displayRole, member.themeColor from loaded team config and inject into teamMetadata field",
      "note": "themeColor is used by UI for rendering member-specific visual styling"
    },
    "dataPreservation": {
      "description": "ETL principle: preserve all data, don't decide for consumers",
      "rule": "Never truncate output, input, or any other field. Consumers (UI/Logger/Context) decide what to display/store"
    },
    "errorHandling": {
      "description": "Invalid JSONL lines should emit error events",
      "rule": "Try JSON.parse(line). If fail, emit error event with original line in error message"
    }
  },

  "exampleConversions": [
    {
      "description": "Codex command execution",
      "input": [
        "{\"type\":\"item.started\",\"item\":{\"id\":\"item_1\",\"type\":\"command_execution\",\"command\":\"/bin/zsh -lc pwd\",\"status\":\"in_progress\"}}",
        "{\"type\":\"item.completed\",\"item\":{\"id\":\"item_1\",\"type\":\"command_execution\",\"command\":\"/bin/zsh -lc pwd\",\"aggregated_output\":\"/Users/...\",\"exit_code\":0,\"status\":\"completed\"}}"
      ],
      "output": [
        "{\"type\":\"tool.started\",\"eventId\":\"evt_001\",\"timestamp\":1732345678901,\"agentId\":\"codex-1\",\"agentType\":\"openai-codex\",\"toolName\":\"Bash\",\"toolId\":\"item_1\",\"input\":{\"command\":\"/bin/zsh -lc pwd\"}}",
        "{\"type\":\"tool.completed\",\"eventId\":\"evt_002\",\"timestamp\":1732345679001,\"agentId\":\"codex-1\",\"agentType\":\"openai-codex\",\"toolId\":\"item_1\",\"output\":\"/Users/...\",\"exitCode\":0,\"status\":\"success\"}"
      ]
    },
    {
      "description": "Claude tool use",
      "input": [
        "{\"type\":\"assistant\",\"message\":{\"content\":[{\"type\":\"tool_use\",\"id\":\"toolu_123\",\"name\":\"Write\",\"input\":{\"file_path\":\"/test.txt\",\"content\":\"Hello\"}}]}}",
        "{\"type\":\"user\",\"message\":{\"content\":[{\"tool_use_id\":\"toolu_123\",\"type\":\"tool_result\",\"content\":\"File created\"}]}}"
      ],
      "output": [
        "{\"type\":\"tool.started\",\"eventId\":\"evt_003\",\"timestamp\":1732345680001,\"agentId\":\"claude-1\",\"agentType\":\"claude-code\",\"toolName\":\"Write\",\"toolId\":\"toolu_123\",\"input\":{\"file_path\":\"/test.txt\",\"content\":\"Hello\"}}",
        "{\"type\":\"tool.completed\",\"eventId\":\"evt_004\",\"timestamp\":1732345681001,\"agentId\":\"claude-1\",\"agentType\":\"claude-code\",\"toolId\":\"toolu_123\",\"output\":\"File created\",\"status\":\"success\"}"
      ]
    },
    {
      "description": "Gemini streaming message",
      "input": [
        "{\"type\":\"message\",\"timestamp\":\"2025-11-23T05:37:17.496Z\",\"role\":\"assistant\",\"content\":\"I have\",\"delta\":true}",
        "{\"type\":\"message\",\"timestamp\":\"2025-11-23T05:37:17.520Z\",\"role\":\"assistant\",\"content\":\" completed the task\",\"delta\":true}"
      ],
      "output": [
        "{\"type\":\"text\",\"eventId\":\"evt_005\",\"timestamp\":1732345037496,\"agentId\":\"gemini-1\",\"agentType\":\"google-gemini\",\"content\":\"I have\",\"role\":\"assistant\",\"delta\":true}",
        "{\"type\":\"text\",\"eventId\":\"evt_006\",\"timestamp\":1732345037520,\"agentId\":\"gemini-1\",\"agentType\":\"google-gemini\",\"content\":\" completed the task\",\"role\":\"assistant\",\"delta\":true}"
      ]
    }
  ],

  "designDecisions": [
    {
      "question": "Should we merge Codex reasoning events into text, or create a separate reasoning event type?",
      "decision": "Merge into text event with category field",
      "rationale": "Simpler schema, fewer event types. UI can differentiate rendering using category (thinking/reasoning vs message/response)"
    },
    {
      "question": "Should tool.started/completed be merged into a single tool event with status field?",
      "decision": "Keep separate (tool.started and tool.completed)",
      "rationale": "Better for real-time streaming display. UI layer decides whether to merge or show separately (like Claude Code/Codex do)"
    },
    {
      "question": "Should we preserve original event metadata (sessionId, uuid, etc.)?",
      "decision": "Yes, preserve all metadata",
      "rationale": "ETL principle: converter should not decide what to keep/discard. Useful for debugging and correlating with agent logs"
    },
    {
      "question": "How to handle Claude's multiple assistant messages in one turn?",
      "decision": "Emit multiple text events (one per message)",
      "rationale": "Preserves streaming order and Claude's characteristic verbosity ('碎嘴子')"
    },
    {
      "question": "Should we truncate large outputs for display?",
      "decision": "No truncation in converter",
      "rationale": "ETL principle: don't decide for consumers. UI/Logger/Context layers handle their own display/storage strategies"
    }
  ]
}
